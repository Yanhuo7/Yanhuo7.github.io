{"meta":{"title":"WTF","subtitle":"","description":"","author":"玄","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2024-05-26T08:05:08.000Z","updated":"2024-05-26T08:05:08.711Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"test","date":"2024-10-07T16:47:57.958Z","updated":"2024-10-07T16:48:46.211Z","comments":true,"path":"2024/10/08/test/","link":"","permalink":"http://example.com/2024/10/08/test/","excerpt":"","text":"测试发布撒大苏打","categories":[],"tags":[]},{"title":"堆算法|Heap algorithm","slug":"堆算法-Heap-algorithm","date":"2024-06-01T15:26:16.000Z","updated":"2024-06-02T10:00:01.363Z","comments":true,"path":"2024/06/01/堆算法-Heap-algorithm/","link":"","permalink":"http://example.com/2024/06/01/%E5%A0%86%E7%AE%97%E6%B3%95-Heap-algorithm/","excerpt":"","text":"1.IntrodutionHeap is a kind of nolinear data structure(complete binary tree) that can be divied into two types，max heap and mini heap. Max heap : any node value &gt;= it’s child node value , root node has the largest value ; Min heap: any node value &lt;= it’s child node value ,root node has the smallest value; As shown below: 2.Common operations of the heap pop heap push heap get the root value of heap get the number of heap nodes determine whether the heap is empty 3.The implementation of heapMax heapThe process of the pushing and poping a heap as follows: The specific code implementation is as follows. We use array to store the value of heap nodes, the left child node index of current node is (2*i+1) , the right child node index of current node is (2*i+2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.demo;import com.sun.corba.se.spi.orb.ParserImplBase;import java.util.ArrayList;import java.util.Arrays;import java.util.Currency;import java.util.List;/** * @author sen * @date 2024 */public class Heap &#123; public static void main(String[] args) &#123; Heap heap1 = new Heap(5); heap1.push(6); heap1.push(5); heap1.push(7); heap1.push(9); System.out.println(Arrays.toString(heap1.heap)); int pop = heap1.pop(); System.out.println(pop); System.out.println(Arrays.toString(heap1.heap)); /**输出 * [9, 7, 6, 5, 0] * 9 * [7, 5, 6, 0, 0] */ &#125; private int[] heap; private int size; private int capacity; private int current; public Heap(int n)&#123; this.size=0; this.capacity=n; this.heap=new int[n]; &#125; public int getParent(int index)&#123; return (index-1)/2; &#125; public int getLeft(int index)&#123; return 2*index+1; &#125; public int getRight(int index)&#123; return 2*index+2; &#125; public void ensureCapacity()&#123; if (size==capacity)&#123; heap = Arrays.copyOf(heap, capacity * 2); capacity *= 2; &#125; &#125; public void swap(int current,int target)&#123; int tmp=heap[target]; heap[target]=heap[current]; heap[current]=tmp; &#125; public void push(int num)&#123; ensureCapacity(); current=size; heap[current]=num;//放到堆尾 ++size;//大小+1 //开始向上堆化 while (current &gt;0 &amp;&amp; heap[current] &gt;heap[getParent(current)] )&#123;//不是根节点 且 节点值大于父节点 swap(current, getParent(current)); //交换完继续重复堆化 current=getParent(current); &#125; &#125; public int pop()&#123; if (size==0)&#123;// return -1; throw new IllegalStateException(&quot;堆为空&quot;); &#125; int pop =heap[0]; current=0; swap(current, size-1); heap[size-1]=0;//删掉交换后的尾部元素 size--; //重新向下堆化// while (heap[current]&lt;heap[getLeft(current)] || heap[current]&lt;heap[getRight(current)])&#123; //这么写不对 数组访问会越界// int right = getRight(current);// int left = getLeft(current);//// if(left&lt;size &amp;&amp; heap[current]&lt;heap[getLeft(current)])&#123;// swap(current, getLeft(current));// current=getLeft(current);// continue;// &#125;//// if(right&lt;size &amp;&amp; heap[current]&lt;heap[getRight(current)])&#123;// swap(current, getRight(current));// current=getRight(current);// &#125;// &#125; //写法1 while (true) &#123; int left = getLeft(current); int right = getRight(current); int largest = current; if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123; largest = left; &#125; if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123; largest = right; &#125; if (largest != current) &#123; swap(current, largest); current = largest;//重新赋值当前索引 ，然后重复执行上述步骤 &#125; else &#123; break; &#125; &#125; return pop; &#125; //方法2 private void heapifyDown(int current) &#123; int largest = current; int left = getLeft(current); int right = getRight(current); if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123; largest = left; &#125; if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123; largest = right; &#125; if (largest != current) &#123; swap(current, largest); heapifyDown(largest);//其实就是重复执行上面的步骤 &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"德州开发笔记","slug":"德州开发笔记","date":"2024-05-26T14:12:29.000Z","updated":"2024-05-26T15:40:16.504Z","comments":true,"path":"2024/05/26/德州开发笔记/","link":"","permalink":"http://example.com/2024/05/26/%E5%BE%B7%E5%B7%9E%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.getClass()方法使用作用：获取运行时对象所属类的详细信息。 getClass() 方法是 Java 中的 Object 类的一部分，每个 Java 对象都继承自 Object 类。因此，所有 Java 对象都可以使用 getClass() 方法。这个方法的作用是返回对象的运行时类对象 (Class 对象)，用于获取对象所属类的详细信息。 getClass() 方法返回一个 Class&lt;?&gt; 类型的对象， 反射操作： 反射是 Java 提供的一种功能，允许在运行时获取类的信息并操作对象。例如： 123Class&lt;?&gt; clazz = object.getClass();Method method = clazz.getMethod(&quot;methodName&quot;);method.invoke(object); 通过 getClass() 获取的 Class 对象，可以进一步获取类的方法、字段、构造函数等信息，并对其进行操作。 类型检查和转换： getClass() 方法可以用于类型检查，以确保对象属于特定的类。例如： 123if (object.getClass() == SomeClass.class) &#123; // 类型匹配&#125; 2.如何重写hashcode方法重写 hashCode 方法的步骤 选择属性： 选择那些参与 equals 方法比较的属性来计算哈希码。 计算哈希码： 使用一个合适的算法来计算哈希码。常见的方法是将这些属性的哈希码组合起来。 作用: 在判断对象是否相等时，首先计算hashcode是否一样，一样再计算对象的属性值内容是否一致 如果hashcode不一样，则对象一定不一样 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Objects;public class Person &#123; private int id; private String name; private int age; public Person(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id &amp;&amp; age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(id, name, age);//使用工具类计算hash &#125; public static void main(String[] args) &#123; Person p1 = new Person(1, &quot;Alice&quot;, 30); Person p2 = new Person(1, &quot;Alice&quot;, 30); Person p3 = new Person(2, &quot;Bob&quot;, 25); System.out.println(p1.hashCode()); // same as p2 System.out.println(p2.hashCode()); // same as p1 System.out.println(p3.hashCode()); // different from p1 and p2 &#125;&#125; 手动计算哈希值 使用31 * n + value的方式计算哈希值，其中n是一个非零常数。这种方式可以提供良好的分布性能，尤其是对于字符串、数组和集合这样的数据结构。 123456789@Overridepublic int hashCode() &#123; int result = 17; // 一个任意的非零常数 result = 31 * result + id; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + age; return result;&#125; 1234567891011@Testpublic void test()&#123; int a =1; int b =3; int c =3; System.out.println(Objects.hash(a)); //输出32 System.out.println(Objects.hash(b)); //34 System.out.println(Objects.hash(c)); //34&#125; 3. Collections.sort用法Collections.sort 是 Java 中用于对列表进行排序的一个静态方法。它提供了简单、方便的方式来对列表中的元素进行自然顺序排序或者根据指定的比较器进行排序。 自然顺序排序是基于元素的自然顺序进行的排序，要求列表中的元素实现 Comparable 接口，并重写 compareTo 方法。 123List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 9, 1, 3); Collections.sort(numbers); System.out.println(numbers); // 输出: [1, 2, 3, 5, 9] Integer 和 String 类都实现了 Comparable 接口，所以可以直接使用 Collections.sort 进行排序。 4. list.sort(Comparator.reverseOrder())对集合降序排序 Comparator.reverseOrder 是 Comparator 接口的一个静态方法，返回一个降序比较器，该比较器是自然顺序的逆序。换句话说，它对元素进行降序排序。 123List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 9, 1, 3); numbers.sort(Comparator.reverseOrder()); System.out.println(numbers); // 输出: [9, 5, 3, 2, 1] 5.list.subList方法从一个 List 中获取其子列表（sublist）。该方法返回的子列表是原列表的视图（view），这意味着对子列表的修改会直接影响原列表，反之亦然。 1List&lt;E&gt; subList(int fromIndex, int toIndex) fromIndex：子列表的起始位置（包含）。 toIndex：子列表的结束位置（不包含）","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-07-15T17:39:46.081Z","updated":"2023-02-11T13:19:08.210Z","comments":true,"path":"2023/07/16/hello-world/","link":"","permalink":"http://example.com/2023/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}