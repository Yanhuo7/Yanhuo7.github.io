{"meta":{"title":"WTF","subtitle":"","description":"","author":"玄","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2024-05-26T08:05:08.000Z","updated":"2024-05-26T08:05:08.711Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"分披萨-一道很有意思的算法题","slug":"分披萨-一道很有意思的算法题","date":"2024-11-02T12:34:29.000Z","updated":"2024-11-02T12:39:36.236Z","comments":true,"path":"2024/11/02/分披萨-一道很有意思的算法题/","link":"","permalink":"http://example.com/2024/11/02/%E5%88%86%E6%8A%AB%E8%90%A8-%E4%B8%80%E9%81%93%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"解题思路： 每次从缺口处拿 ，难点是缺口在数据结构中怎么处理。每次怎么拿缺口的数据 刚开始的思路是使用数组存储数据，如下图，维护一个缺口窗口， 每次向两边扩大窗口（判断两边哪个数据更大），直到元素都使用了 j=(j+1)%5 i=i-1 如果i-1&lt;0 则 i= (i-1)+5 更好的思路： 使用linkedlist，双向链表！优雅实现缺口效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); for (int i=0;i&lt;n;i++)&#123; linkedList.add(sc.nextInt()); &#125; int sum1=0; int sum2=0; int max=0; for (int i=0;i&lt;n;i++)&#123;//重复首次从第i个位置先拿披萨 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(linkedList); int k=0; while (k&lt;i)&#123; Integer poll = list.poll(); list.addLast(poll); k++; &#125; Integer poll = list.poll(); sum1+=poll; while (!list.isEmpty())&#123; if(list.getFirst()&gt;list.getLast())&#123; sum2+=list.pollFirst(); &#125;else &#123; sum2+=list.pollLast(); &#125; if(list.getFirst()&gt;list.getLast())&#123; sum1+=list.pollFirst(); &#125;else &#123; sum1+=list.pollLast(); &#125; &#125; max=Math.max(max, sum1); sum1=sum2=0; &#125; System.out.println(&quot;吃货能分得到的最大的披萨大小的总和。&quot;+max);&#125;","categories":[],"tags":[]},{"title":"lookup注解","slug":"lookup注解","date":"2024-10-10T12:16:23.000Z","updated":"2024-10-15T19:05:11.764Z","comments":true,"path":"2024/10/10/lookup注解/","link":"","permalink":"http://example.com/2024/10/10/lookup%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"lookup注解有时我们希望单例Bean能够依赖于多例Bean（prototype范围的Bean） @Lookup注解提供了一种解决方案，允许单例Bean在运行时动态地获取多例Bean的实例。 ==使用@Lookup注解来确保每次调用时都会注入一个新的prototype作用域的UserSession实例== @Lookup注解可以应用于方法上，Spring容器会拦截该方法的调用，并返回一个多例Bean的实例。@Lookup方法的返回类型必须是多例Bean的类型，方法的参数（如果有的话）将作为构造函数或工厂方法的参数传递给多例Bean。 案例 12345678910111213141516171819import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component@Scope(&quot;prototype&quot;)public class PrototypeBean &#123; private static int instanceCount = 0; private int instanceId; public PrototypeBean() &#123; instanceCount++; instanceId = instanceCount; System.out.println(&quot;Creating PrototypeBean instance &quot; + instanceId); &#125; public void doSomething() &#123; System.out.println(&quot;PrototypeBean instance &quot; + instanceId + &quot; is doing something.&quot;); &#125;&#125; 单例Bean 1234567891011121314import org.springframework.beans.factory.annotation.Lookup;import org.springframework.stereotype.Component;@Componentpublic abstract class SingletonBean &#123; public void usePrototypeBean() &#123; PrototypeBean prototypeBean = getPrototypeBean(); prototypeBean.doSomething(); &#125; @Lookup protected PrototypeBean getPrototypeBean();&#125; 配置 1234567import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &quot;com.example&quot;)public class AppConfig &#123;&#125; 使用示例 1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); SingletonBean singletonBean = context.getBean(SingletonBean.class); singletonBean.usePrototypeBean(); singletonBean.usePrototypeBean(); singletonBean.usePrototypeBean(); &#125;&#125; 输出结果 123456Creating PrototypeBean instance 1PrototypeBean instance 1 is doing something.Creating PrototypeBean instance 2PrototypeBean instance 2 is doing something.Creating PrototypeBean instance 3PrototypeBean instance 3 is doing something. 解释 多例Bean：PrototypeBean 是一个多例Bean，每次请求时都会创建一个新的实例。 单例Bean：SingletonBean 是一个单例Bean，它在Spring容器启动时创建，并且在整个应用程序生命周期中只有一个实例。 @Lookup方法：SingletonBean 中的 getPrototypeBean 方法被 @Lookup 注解标记，Spring容器会在运行时拦截该方法的调用，并返回一个新的 PrototypeBean 实例。","categories":[],"tags":[]},{"title":"test4","slug":"volatile关键字","date":"2024-10-08T15:54:35.000Z","updated":"2024-10-08T15:54:35.698Z","comments":true,"path":"2024/10/08/volatile关键字/","link":"","permalink":"http://example.com/2024/10/08/volatile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"spring中bean的范围为prototype多例使用场景","slug":"spring中bean的范围为prototype多例使用场景","date":"2024-10-06T07:53:43.000Z","updated":"2024-10-15T19:00:26.457Z","comments":true,"path":"2024/10/06/spring中bean的范围为prototype多例使用场景/","link":"","permalink":"http://example.com/2024/10/06/spring%E4%B8%ADbean%E7%9A%84%E8%8C%83%E5%9B%B4%E4%B8%BAprototype%E5%A4%9A%E4%BE%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"spring中bean的范围为prototype多例使用场景由于单例Bean在容器启动时就已经创建，而多例Bean在每次请求时才会创建 prototype作用域意味着每次请求Bean时都会创建一个新的实例。与默认的singleton作用域不同，prototype适用于需要每次都生成新的对象的场景 案例： 生成用户会话对象 定义多例模式的类 12345678910111213141516171819202122@Component@Scope(&quot;prototype&quot;)public class UserSession &#123; private String userId; public UserSession() &#123; System.out.println(&quot;创建新的用户会话类&quot;); &#125; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public void printSessionDetails() &#123; System.out.println(&quot;User ID : &quot; + userId); &#125;&#125; 在UserService类中，我们可以使用@Lookup注解来确保每次调用时都会获得一个新的UserSession实例。 12345678910111213141516171819import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; // 使用 @Lookup 注解确保每次都获取新的 UserSession 实例 @Lookup public UserSession getUserSession() &#123; // Spring会自动重写这个方法，并返回一个新的UserSession实例 return null; // 这个返回值不会被实际使用 &#125; public void loginUser(String userId) &#123; // 每次调用时会创建一个新的 UserSession 实例 UserSession userSession = getUserSession(); userSession.setUserId(userId); userSession.printSessionDetails(); &#125;&#125; 然后，在其他地方调用service的loginUser方法时，每次都会生成新的实例 prototype Bean在Spring容器中并不会自动销毁。当程序使用完UserSession后，Spring不再跟踪它，也不负责其生命周期管理。在完成业务操作后，该实例将被GC（垃圾回收）回收。 销毁管理：由于Spring容器不管理prototype Bean的销毁，开发者需要注意该实例的资源管理。如果UserSession包含任何需要手动释放的资源（例如数据库连接、文件句柄等），则需要在合适的地方手动进行资源释放。 垃圾回收：在该实例不再被引用时，JVM会自动进行垃圾回收。 与singleton作用域对比 singleton作用域：singleton Bean是默认作用域，实例在Spring容器启动时被创建，并在整个应用的生命周期内存在。Spring会自动管理它的生命周期，包括实例化、依赖注入、使用以及在容器关闭时销毁。 prototype作用域：prototype Bean则由容器创建，并且仅负责实例化阶段，容器不会对实例的后续生命周期负责。","categories":[],"tags":[]},{"title":"synchronized 锁升级","slug":"synchronized 锁升级","date":"2024-09-22T07:53:50.000Z","updated":"2024-10-13T19:57:00.328Z","comments":true,"path":"2024/09/22/synchronized 锁升级/","link":"","permalink":"http://example.com/2024/09/22/synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7/","excerpt":"","text":"synchronized 锁升级Java 的 synchronized 锁采用了锁的优化机制，包括偏向锁、轻量级锁和重量级锁，根据不同的竞争情况，锁会在这几种状态之间进行升级和转换。 锁的升级是从偏向锁开始，如果锁竞争逐渐变得激烈，它会升级为轻量级锁，最后升级为重量级锁。这个升级过程遵循一个由低到高的路径，但锁一旦升级，就不会降级。 锁的四种状态 无锁状态：对象没有任何线程竞争。 偏向锁（Biased Locking）：==线程第一次获取锁后，偏向于该线程==，之后同一线程再次获得锁时无需加锁操作。 轻量级锁（Lightweight Locking）：在有多个线程争抢锁的情况下，通过 CAS 操作自旋以尝试获取锁，避免进入内核态的阻塞操作。 重量级锁（Heavyweight Locking）：当自旋多次失败，锁升级为重量级锁，进入操作系统的锁机制，线程会被阻塞，等待操作系统的调度。 锁升级的过程 偏向锁（Biased Lock） 偏向锁用于减少线程获取锁时的开销。当一个线程第一次获取锁时，JVM 会将该锁偏向这个线程，在之后该线程尝试获取相同的锁时，它不需要进行任何同步操作（如 CAS 或加锁操作），直接通过。偏向锁适用于没有竞争或锁被同一线程多次获取的场景。 偏向锁的工作原理 当一个线程第一次获取锁时，JVM 会将该线程的 ID 记录在锁对象的对象头中，表示该锁偏向这个线程。 之后，如果同一个线程再次请求这把锁，不需要进行同步操作，直接使用。 如果有其他线程尝试获取这把锁，偏向锁会被撤销，并升级为轻量级锁。 偏向锁的撤销： 偏向锁是一个无竞争的优化策略，一旦发现有其他线程竞争锁（其他线程尝试获取偏向锁），就会撤销偏向锁，进入轻量级锁。 轻量级锁（Lightweight Lock） 当偏向锁撤销后，锁会升级为轻量级锁。轻量级锁适用于多个线程竞争但时间较短的情况。轻量级锁通过CAS自旋来避免线程阻塞。 轻量级锁的工作原理： 当一个线程尝试获取轻量级锁时，会尝试通过 CAS 操作将锁对象的 Mark Word 替换为指向该线程栈帧的锁记录。如果 CAS 操作成功，该线程就获得了锁。 如果 CAS 失败，表示其他线程已经持有锁，此时线程会进入自旋，即反复尝试 CAS 操作，直到锁被释放。 自旋锁：自旋锁避免了线程进入阻塞状态，减少了上下文切换的开销。但是，自旋会消耗 CPU 资源，因此自旋的次数是有限的（可以通过 JVM 参数调整自旋次数，默认值是 10 次）。 轻量级锁的升级： 如果自旋多次后仍然无法获取锁，表示锁竞争非常激烈，此时轻量级锁会升级为重量级锁。 3. 重量级锁 当自旋锁也无法成功获取锁时，锁会升级为重量级锁，这时 Java 会使用底层的操作系统的锁机制，线程会进入阻塞状态，等待操作系统调度。 重量级锁的工作原理： 重量级锁通过操作系统的互斥锁机制来保证线程的互斥访问。当一个线程持有锁时，其他竞争的线程会被阻塞，进入操作系统的等待队列，直到持有锁的线程释放锁。 重量级锁的缺点： 由于需要依赖操作系统的调度机制，线程的阻塞和唤醒会产生额外的上下文切换，开销较大，因此重量级锁的性能较低。 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; Object lock = new Object(); // 偏向锁阶段 synchronized (lock) &#123; System.out.println(&quot;偏向锁阶段&quot;); &#125; // 多线程竞争，升级为轻量级锁 for (int i = 0; i &lt; 2; i++) &#123; new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; 轻量级锁阶段&quot;); &#125; &#125;).start(); &#125; // 等待线程竞争加剧，锁升级为重量级锁 new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(&quot;重量级锁阶段&quot;); &#125; &#125;).start();&#125;","categories":[],"tags":[]},{"title":"常用的JVM调优参数","slug":"常用的JVM调优参数","date":"2024-09-20T15:53:43.000Z","updated":"2024-10-13T19:17:45.731Z","comments":true,"path":"2024/09/20/常用的JVM调优参数/","link":"","permalink":"http://example.com/2024/09/20/%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/","excerpt":"","text":"常用的JVM调优参数一、堆内存设置 -Xms 和 -Xmx：设置初始堆大小和最大堆大小。 -Xms 初始化时的堆大小。设置得大一些可以避免频繁动态扩展堆。 -Xmx 设置堆内存的最大值。设置的太小可能导致 OutOfMemoryError，设置的太大可能导致 GC 时间过长。 示例：-Xms512m -Xmx4g 这表示堆的初始大小为 512 MB，最大可以扩展到 4 GB。 -XX:MaxPermSize=&lt;size&gt;: 设置永久代大小（Java 8 及之前版本）。 -XX:MaxMetaspaceSize=&lt;size&gt;: 设置元数据空间大小（Java 8 及之后版本）。 -XX:SurvivorRatio=&lt;ratio&gt;: 设置新生代中 Eden 区与 Survivor 区的比例。 二、新生代和老年代设置 -Xmn 设置新生代大小。通常建议新生代占总堆的1/3，这样可以提高新生代GC的效率。 示例：-Xmn1g，表示新生代大小为1 GB。 -XX:NewRatio= 设置新生代和老年代的比例。这个比例决定了JVM在堆内存中为新生代和老年代分配的内存大小。 示例： -XX:NewRatio=2：表示新生代与老年代的比例为1:2（新生代占总堆内存的1/3）。 -XX:NewRatio=4：表示新生代与老年代的比例为1:4（新生代占总堆内存的1/5），适合对象存活时间较长的场景。 三、垃圾回收相关参数 -XX:+UseParallelGC 用于选择适合应用场景的垃圾收集器。 使用 Parallel GC（并行垃圾收集器），这是 JDK 1.8 的默认垃圾收集器，适合高吞吐量应用。 使用其他垃圾收集器，示例： -XX:+UseSerialGC：使用串行垃圾回收器。 -XX:+UseG1GC：使用G1垃圾回收器。 -XX:MaxGCPauseMillis= 设置GC最大暂停时间。 垃圾回收过程中应用程序的最大允许暂停时间 示例：-XX:MaxGCPauseMillis=200，GC最大暂停时间为200毫秒。 注意： 默认情况下，VM没有暂停时间目标值。GC的暂停时间主要取决于堆中实时数据的数量与实时数据量。 -XX:GCTimeRatio= 设置垃圾回收占总运行时间的比例。表示希望在GC花费不超过应用程序执行时间的1/(1+)，为大于0小于100的整数。 默认值是99，表示允许1%的时间用于GC，适合希望优化吞吐量的场景。 -XX:MaxTenuringThreshold= 设置对象从新生代晋升到老年代的年龄阈值。适合调节对象的存活时间，影响GC频率和性能。 示例：-XX:MaxTenuringThreshold=15，表示对象在新生代存活15次后才会晋升到老年代。 四、线程栈大小 -Xss 设置每个线程的栈大小。栈用于存储方法的局部变量、操作数栈、动态链接和返回地址。较大的栈大小可以支持更深的递归，但会消耗更多的内存。 示例：-Xss512k 这表示每个线程的栈大小为512 KB。适用于大多数应用 五、调试和监控参数 -XX:+PrintGCDetails 打印详细的GC信息，帮助开发者分析内存使用情况。 -XX:+PrintGCTimeStamps 在GC日志中添加时间戳，方便分析GC发生的具体时间 -Xloggc:： 将GC日志输出到指定文件，便于后续分析和监控。","categories":[],"tags":[]},{"title":"vuex如何使用","slug":"vuex的使用","date":"2024-06-08T12:54:39.000Z","updated":"2024-10-13T19:59:35.203Z","comments":true,"path":"2024/06/08/vuex的使用/","link":"","permalink":"http://example.com/2024/06/08/vuex%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"如何使用vuex步骤1：定义一个store.js文件，在这个里面import vuex 和vue， 并将vuex绑定到vue上，不是非要在main.ts里面这样写。 然后export一个 Vuex实例 1234567891011import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; pageLoading: false, useRoles: [], &#125;, ... 步骤2： 在main.ts 页面 导入 并添加到Vue对象中 然后就可以通过 this.$store的方式来使用我们定义的store实例 12345678910111213import store from &#x27;./store&#x27;new Vue(&#123; router, store, pinia, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 案例123456789101112131415161718192021222324export default new Vuex.Store(&#123; state: &#123; pageLoading: false, useRoles: [], &#125;, mutations: &#123; setLoading(state, data, rootState) &#123; state.pageLoading = data[0] &#125;, setUserRoles(state, data)&#123; //注意 可以在App.vue页面获取用户信息然后进行存储 state.useRoles = data; &#125;, &#125;, actions: &#123; &#125;, modules: &#123; &#125;, getters:&#123; getUserRoles: state =&gt; state.useRoles &#125;&#125;) 说明： state 是 Vuex 中存储应用程序状态的对象。在这个例子中，state 对象包含两个属性：pageLoading 和 useRoles，分别表示当前页面是否正在加载和用户的角色列表。 mutations 是一组同步的函数，用于修改 state 中的数据 actions 是一组异步的函数，用于处理异步操作和提交 mutations。 modules 允许将 store 分割成模块，每个模块都拥有自己的 state、mutations、actions、getters 等属性。 getters 用于从 state 中派生出一些状态，例如根据用户角色列表过滤数据等。在这个例子中，定义了一个名为 getUserRoles 的 getter 函数，它返回用户角色列表。 最后，通过 export default new Vuex.Store(&#123;...&#125;) 语句将创建的 store 实例导出，以便在 Vue 组件中使用。 如何在vue中使用store实例访问state对象里的状态 1this.$store.state.xxx 存储、提交mutations 1this.$store.commit(&#x27;setUserRoles&#x27;, res.data.roles); 使用actions 1234getUserInfo() &#123; this.$store.dispatch(&#x27;getUserInfo&#x27;).then((userInfo) =&gt; &#123; // 处理用户信息 &#125;); 获取getters里面定义的扩展对象 1234//是否招聘专员 isRecruitOfficer() &#123; return this.$store.getters.getUserRoles.includes(&#x27;招聘专员&#x27;); &#125;, mutations 同步的函数和actions异步函数的区别在 Vuex 中， mutations 和 actions 都是用来管理状态的函数。它们都可以被调用来改变 Vuex store 中的数据。不过，它们有一个重要的区别：mutations 同步执行，而 actions 异步执行。 当调用 mutations 的时候，它会直接修改 state 中的数据，而且这个操作是同步执行的。意味着在 mutations 应用了某个操作之后，可以立即知道 state 中的数据已经被更新了。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;&#125;)store.commit(&#x27;increment&#x27;)console.log(store.state.count) // 输出 1 1234567891011121314151617181920onst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;, actions: &#123; incrementAsync(context) &#123; setTimeout(() =&gt; &#123; context.commit(&#x27;increment&#x27;) &#125;, 1000) &#125; &#125;&#125;)store.dispatch(&#x27;incrementAsync&#x27;)console.log(store.state.count) // 输出 0 context变量 在 Vuex 的 actions 中，第一个参数是一个上下文对象（context）。这个上下文对象包含了一些有用的属性和方法，比如 state、commit、dispatch 等等。可以调用 mutation 和 action，还可以访问 state 中的数据。 context 变量是一个包含了 Vuex store 实例中属性和方法的对象。通过 context 对象可以调用 mutation 和 action，以及访问 state 中的数据。","categories":[],"tags":[]},{"title":"堆算法|Heap algorithm","slug":"堆算法-Heap-algorithm","date":"2024-06-01T15:26:16.000Z","updated":"2024-06-02T10:00:01.363Z","comments":true,"path":"2024/06/01/堆算法-Heap-algorithm/","link":"","permalink":"http://example.com/2024/06/01/%E5%A0%86%E7%AE%97%E6%B3%95-Heap-algorithm/","excerpt":"","text":"1.IntrodutionHeap is a kind of nolinear data structure(complete binary tree) that can be divied into two types，max heap and mini heap. Max heap : any node value &gt;= it’s child node value , root node has the largest value ; Min heap: any node value &lt;= it’s child node value ,root node has the smallest value; As shown below: 2.Common operations of the heap pop heap push heap get the root value of heap get the number of heap nodes determine whether the heap is empty 3.The implementation of heapMax heapThe process of the pushing and poping a heap as follows: The specific code implementation is as follows. We use array to store the value of heap nodes, the left child node index of current node is (2*i+1) , the right child node index of current node is (2*i+2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.demo;import com.sun.corba.se.spi.orb.ParserImplBase;import java.util.ArrayList;import java.util.Arrays;import java.util.Currency;import java.util.List;/** * @author sen * @date 2024 */public class Heap &#123; public static void main(String[] args) &#123; Heap heap1 = new Heap(5); heap1.push(6); heap1.push(5); heap1.push(7); heap1.push(9); System.out.println(Arrays.toString(heap1.heap)); int pop = heap1.pop(); System.out.println(pop); System.out.println(Arrays.toString(heap1.heap)); /**输出 * [9, 7, 6, 5, 0] * 9 * [7, 5, 6, 0, 0] */ &#125; private int[] heap; private int size; private int capacity; private int current; public Heap(int n)&#123; this.size=0; this.capacity=n; this.heap=new int[n]; &#125; public int getParent(int index)&#123; return (index-1)/2; &#125; public int getLeft(int index)&#123; return 2*index+1; &#125; public int getRight(int index)&#123; return 2*index+2; &#125; public void ensureCapacity()&#123; if (size==capacity)&#123; heap = Arrays.copyOf(heap, capacity * 2); capacity *= 2; &#125; &#125; public void swap(int current,int target)&#123; int tmp=heap[target]; heap[target]=heap[current]; heap[current]=tmp; &#125; public void push(int num)&#123; ensureCapacity(); current=size; heap[current]=num;//放到堆尾 ++size;//大小+1 //开始向上堆化 while (current &gt;0 &amp;&amp; heap[current] &gt;heap[getParent(current)] )&#123;//不是根节点 且 节点值大于父节点 swap(current, getParent(current)); //交换完继续重复堆化 current=getParent(current); &#125; &#125; public int pop()&#123; if (size==0)&#123;// return -1; throw new IllegalStateException(&quot;堆为空&quot;); &#125; int pop =heap[0]; current=0; swap(current, size-1); heap[size-1]=0;//删掉交换后的尾部元素 size--; //重新向下堆化// while (heap[current]&lt;heap[getLeft(current)] || heap[current]&lt;heap[getRight(current)])&#123; //这么写不对 数组访问会越界// int right = getRight(current);// int left = getLeft(current);//// if(left&lt;size &amp;&amp; heap[current]&lt;heap[getLeft(current)])&#123;// swap(current, getLeft(current));// current=getLeft(current);// continue;// &#125;//// if(right&lt;size &amp;&amp; heap[current]&lt;heap[getRight(current)])&#123;// swap(current, getRight(current));// current=getRight(current);// &#125;// &#125; //写法1 while (true) &#123; int left = getLeft(current); int right = getRight(current); int largest = current; if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123; largest = left; &#125; if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123; largest = right; &#125; if (largest != current) &#123; swap(current, largest); current = largest;//重新赋值当前索引 ，然后重复执行上述步骤 &#125; else &#123; break; &#125; &#125; return pop; &#125; //方法2 private void heapifyDown(int current) &#123; int largest = current; int left = getLeft(current); int right = getRight(current); if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123; largest = left; &#125; if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123; largest = right; &#125; if (largest != current) &#123; swap(current, largest); heapifyDown(largest);//其实就是重复执行上面的步骤 &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"德州开发笔记","slug":"德州开发笔记","date":"2024-05-26T14:12:29.000Z","updated":"2024-05-26T15:40:16.504Z","comments":true,"path":"2024/05/26/德州开发笔记/","link":"","permalink":"http://example.com/2024/05/26/%E5%BE%B7%E5%B7%9E%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.getClass()方法使用作用：获取运行时对象所属类的详细信息。 getClass() 方法是 Java 中的 Object 类的一部分，每个 Java 对象都继承自 Object 类。因此，所有 Java 对象都可以使用 getClass() 方法。这个方法的作用是返回对象的运行时类对象 (Class 对象)，用于获取对象所属类的详细信息。 getClass() 方法返回一个 Class&lt;?&gt; 类型的对象， 反射操作： 反射是 Java 提供的一种功能，允许在运行时获取类的信息并操作对象。例如： 123Class&lt;?&gt; clazz = object.getClass();Method method = clazz.getMethod(&quot;methodName&quot;);method.invoke(object); 通过 getClass() 获取的 Class 对象，可以进一步获取类的方法、字段、构造函数等信息，并对其进行操作。 类型检查和转换： getClass() 方法可以用于类型检查，以确保对象属于特定的类。例如： 123if (object.getClass() == SomeClass.class) &#123; // 类型匹配&#125; 2.如何重写hashcode方法重写 hashCode 方法的步骤 选择属性： 选择那些参与 equals 方法比较的属性来计算哈希码。 计算哈希码： 使用一个合适的算法来计算哈希码。常见的方法是将这些属性的哈希码组合起来。 作用: 在判断对象是否相等时，首先计算hashcode是否一样，一样再计算对象的属性值内容是否一致 如果hashcode不一样，则对象一定不一样 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Objects;public class Person &#123; private int id; private String name; private int age; public Person(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return id == person.id &amp;&amp; age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(id, name, age);//使用工具类计算hash &#125; public static void main(String[] args) &#123; Person p1 = new Person(1, &quot;Alice&quot;, 30); Person p2 = new Person(1, &quot;Alice&quot;, 30); Person p3 = new Person(2, &quot;Bob&quot;, 25); System.out.println(p1.hashCode()); // same as p2 System.out.println(p2.hashCode()); // same as p1 System.out.println(p3.hashCode()); // different from p1 and p2 &#125;&#125; 手动计算哈希值 使用31 * n + value的方式计算哈希值，其中n是一个非零常数。这种方式可以提供良好的分布性能，尤其是对于字符串、数组和集合这样的数据结构。 123456789@Overridepublic int hashCode() &#123; int result = 17; // 一个任意的非零常数 result = 31 * result + id; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + age; return result;&#125; 1234567891011@Testpublic void test()&#123; int a =1; int b =3; int c =3; System.out.println(Objects.hash(a)); //输出32 System.out.println(Objects.hash(b)); //34 System.out.println(Objects.hash(c)); //34&#125; 3. Collections.sort用法Collections.sort 是 Java 中用于对列表进行排序的一个静态方法。它提供了简单、方便的方式来对列表中的元素进行自然顺序排序或者根据指定的比较器进行排序。 自然顺序排序是基于元素的自然顺序进行的排序，要求列表中的元素实现 Comparable 接口，并重写 compareTo 方法。 123List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 9, 1, 3); Collections.sort(numbers); System.out.println(numbers); // 输出: [1, 2, 3, 5, 9] Integer 和 String 类都实现了 Comparable 接口，所以可以直接使用 Collections.sort 进行排序。 4. list.sort(Comparator.reverseOrder())对集合降序排序 Comparator.reverseOrder 是 Comparator 接口的一个静态方法，返回一个降序比较器，该比较器是自然顺序的逆序。换句话说，它对元素进行降序排序。 123List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 9, 1, 3); numbers.sort(Comparator.reverseOrder()); System.out.println(numbers); // 输出: [9, 5, 3, 2, 1] 5.list.subList方法从一个 List 中获取其子列表（sublist）。该方法返回的子列表是原列表的视图（view），这意味着对子列表的修改会直接影响原列表，反之亦然。 1List&lt;E&gt; subList(int fromIndex, int toIndex) fromIndex：子列表的起始位置（包含）。 toIndex：子列表的结束位置（不包含）","categories":[],"tags":[]}],"categories":[],"tags":[]}